cost <- sse/(2*length(y))
grad <- (sum(hx-y)) %*% feature
print(grad)
}
linReg(feature, y, theta)
linReg <- function(feature, y, theta) {
hx <- feature %*% t(theta)
sse <- sum((hx-y)^2)
print(sse)
cost <- sse/(2*length(y))
grad <- (sum(hx-y)) * feature
print(grad)
}
linReg(feature, y, theta)
linReg <- function(feature, y, theta) {
hx <- feature %*% t(theta)
sse <- sum((hx-y)^2)
print(sse)
cost <- sse/(2*length(y))
grad <- ((sum(hx-y)) * feature)/(length(y))
print(grad)
}
linReg(feature, y, theta)
linReg <- function(feature, y, theta) {
hx <- feature %*% t(theta)
sse <- sum((hx-y)^2)
print(sse)
cost <- sse/(2*length(y))
grad <- ((sum((hx-y) * feature)))/(length(y))
print(grad)
}
linReg(feature, y, theta)
temph <- feature %*% t(theta)
temph-y
feature
(temph-y)*feature
(temph-y)%*%*feature
(temph-y)%*%feature
sum(temph-y) * feature
t(feature)
t(feature) * (temph-y)
t(feature) %*% (temph-y)
theta
linReg <- function(feature, y, theta) {
hx <- feature %*% t(theta)
sse <- sum((hx-y)^2)
print(sse)
cost <- sse/(2*length(y))
grad <- ((t(feature) %*% (hx-y))
print(grad)
}
linReg <- function(feature, y, theta) {
hx <- feature %*% t(theta)
sse <- sum((hx-y)^2)
print(sse)
cost <- sse/(2*length(y))
grad <- (t(feature) %*% (hx-y))
print(grad)
}
linReg(feature, y, theta)
theta
feature
theta <- matrix(c(1,1), nrow=2)
feature %*% theta
theta <- matrix(c(1,1), nrow=2)
linReg <- function(feature, y, theta) {
hx <- feature %*% theta
sse <- sum((hx-y)^2)
print(sse)
cost <- sse/(2*length(y))
grad <- (t(feature) %*% (hx-y))
print(grad)
}
linReg(feature, y, theta)
linReg <- function(feature, y, theta) {
hx <- feature %*% theta
sse <- sum((hx-y)^2)
print(sse)
cost <- sse/(2*length(y))
grad <- (t(feature) %*% (hx-y))
return(grad)
}
theta_update <- function(alpha, steps) {
for (i in 1:steps) {
theta <- theta - (alpha)/(linReg(feature, y, theta))
}
return(theta)
}
theta_update(1, 10)
linReg <- function(feature, y, theta, alpha, steps) {
hx <- feature %*% theta
sse <- sum((hx-y)^2)
cost <- sse/(2*length(y))
grad <- (t(feature) %*% (hx-y))
return(grad)
for (i in 1:steps) {
theta <- theta - (alpha)/(linReg(feature, y, theta))
}
return(theta)
}
linReg(feature, y, theta, 1, 10)
linReg <- function(feature, y, theta, alpha, steps) {
hx <- feature %*% theta
sse <- sum((hx-y)^2)
cost <- sse/(2*length(y))
grad <- (t(feature) %*% (hx-y))
for (i in 1:steps) {
theta <- theta - (alpha)/(linReg(feature, y, theta))
}
return(theta)
}
linReg(feature, y, theta, 1, 10)
linReg(feature = feature, y = y, theta=theta, alpha = 1, steps = 10)
linReg <- function(feature, y, theta, alpha, steps) {
hx <- feature %*% theta
sse <- sum((hx-y)^2)
cost <- sse/(2*length(y))
grad <- (t(feature) %*% (hx-y))
for (i in 1:steps) {
theta <- theta - (alpha)/(grad)
}
return(theta)
}
linReg(feature = feature, y = y, theta=theta, alpha = 1, steps = 10)
fit
linReg(feature = feature, y = y, theta=theta, alpha = 1, steps = 100)
linReg(feature = feature, y = y, theta=theta, alpha = 1, steps = 10000)
linReg(feature = feature, y = y, theta=theta, alpha = 1, steps = 100000)
linReg(feature = feature, y = y, theta=theta, alpha = .1, steps = 1000)
linReg(feature = feature, y = y, theta=theta, alpha = .1, steps = 10000)
linReg(feature = feature, y = y, theta=theta, alpha = .1, steps = 100000)
linReg(feature = feature, y = y, theta=theta, alpha = .1, steps = 1000000)
linReg(feature = feature, y = y, theta=theta, alpha = .1, steps = 100000)
linReg(feature = feature, y = y, theta=theta, alpha = .1, steps = 200000)
linReg(feature = feature, y = y, theta=theta, alpha = .1, steps = 100000)
fit
linReg <- function(feature, y, theta, alpha, steps) {
hx <- feature %*% theta
sse <- sum((hx-y)^2)
cost <- sse/(2*length(y))
grad <- (t(feature) %*% (hx-y))
for (i in 1:steps) {
theta <- theta - (alpha/length(y))/(grad)
}
return(theta)
}
linReg(feature = feature, y = y, theta=theta, alpha = .1, steps = 100000)
theta
linReg(feature = feature, y = y, theta=theta, alpha = .1, steps = 10000)
linReg <- function(feature, y, theta, alpha, steps) {
hx <- feature %*% theta
sse <- sum((hx-y)^2)
cost <- sse/(2*length(y))
grad <- (t(feature) %*% (hx-y))
for (i in 1:steps) {
theta <- theta - (alpha/length(y))/(grad)
print(theta)
}
return(theta)
}
linReg(feature = feature, y = y, theta=theta, alpha = .1, steps = 10000)
length(y)
linReg <- function(feature, y, theta, alpha, steps) {
for (i in 1:steps) {
hx <- feature %*% theta
sse <- sum((hx-y)^2)
cost <- sse/(2*length(y))
grad <- (t(feature) %*% (hx-y))
theta <- theta - (alpha/length(y))/(grad)
print(theta)
}
}
linReg(feature = feature, y = y, theta=theta, alpha = .1, steps = 10000)
linReg <- function(feature, y, theta, alpha, steps) {
hx <- feature %*% theta
sse <- sum((hx-y)^2)
cost <- sse/(2*length(y))
grad <- (t(feature) %*% (hx-y))
theta <- theta - (alpha/length(y))/(grad)
}
linReg(feature = feature, y = y, theta=theta, alpha = .1, steps = 10000)
linReg <- function(feature, y, theta, alpha, steps) {
hx <- feature %*% theta
sse <- sum((hx-y)^2)
cost <- sse/(2*length(y))
grad <- (t(feature) %*% (hx-y))
theta <- theta - (alpha/length(y))/(grad)
return(theta)
}
linReg(feature = feature, y = y, theta=theta, alpha = .1, steps = 10000)
theta
linTrain <- function(alpha, steps) {
for (i in 0:steps) {
print(i)
}
}
linTrain(1, 10)
linReg <- function(feature, y, theta) {
hx <- feature %*% theta
sse <- sum((hx-y)^2)
cost <- sse/(2*length(y))
grad <- (t(feature) %*% (hx-y))
theta <- theta - (grad)*(alpha/length(y))
return(theta)
}
linTrain <- function(alpha, steps) {
for (i in 0:steps) {
theta <- linReg(feature, y, theta)
linReg(feature, y, theta)
}
}
linTrain(1, 100)
linReg <- function(feature, y, theta, alpha) {
hx <- feature %*% theta
sse <- sum((hx-y)^2)
cost <- sse/(2*length(y))
grad <- (t(feature) %*% (hx-y))
theta <- theta - (grad)*(alpha/length(y))
return(theta)
}
linTrain <- function(alpha, steps) {
for (i in 0:steps) {
theta <- linReg(feature, y, theta, alpha)
linReg(feature, y, theta)
}
}
linTrain(1, 100)
linReg <- function(feature, y, theta, alpha) {
hx <- feature %*% theta
sse <- sum((hx-y)^2)
cost <- sse/(2*length(y))
grad <- (t(feature) %*% (hx-y))
theta <- theta - (grad)*(alpha/length(y))
return(theta)
}
linTrain <- function(alpha, steps) {
for (i in 0:steps) {
theta <- linReg(feature, y, theta, alpha)
linReg(feature, y, theta, alpha)
}
}
linTrain(1, 100)
linReg <- function(feature, y, theta, alpha) {
hx <- feature %*% theta
sse <- sum((hx-y)^2)
cost <- sse/(2*length(y))
grad <- (t(feature) %*% (hx-y))
theta <- theta - (grad)*(alpha/length(y))
return(theta)
}
linTrain <- function(alpha, steps) {
for (i in 0:steps) {
theta <- linReg(feature, y, theta, alpha)
linReg(feature, y, theta, alpha)
}
return(theta)
}
linTrain(1, 100)
linTrain(.01, 100)
linTrain(.01, 1000)
linTrain(.01, 10000)
linTrain(.01, 100000)
fit
linTrain(.01, 1000)
linReg <- function(feature, y, theta, alpha) {
hx <- feature %*% theta
sse <- sum((hx-y)^2)
cost <- sse/(2*length(y))
grad <- (t(feature) %*% (hx-y))
theta <- theta - (grad)*(alpha/length(y))
return(theta)
}
linTrain <- function(alpha, steps) {
for (i in 0:steps) {
theta <- linReg(feature, y, theta, alpha)
}
return(theta)
}
linTrain(.01, 1000)
linTrain(.01, 5000)
linTrain(.01, 9000)
fit
require(rattle)
fancyRpartPlot
data(spam)
require(kernlab)
data(spam)
require(rpart)
head(spam)
spam_clf <- rpart(type~., data=spam)
fancyRpartPlot(spam_clf)
plot(spam_clf)
text(spam_clf)
install.packages(c("codetools", "colorspace", "gbm", "manipulate", "memisc", "quantmod"))
require(manipulate)
dimnames(USArrests)
USArrests
class(USArrests)
apply(USArrests,2,mean)
apply(USArrests,2, var)
pca.out=prcomp(USArrests, scale=TRUE)
pca.out
names(pca.out)
biplot(pca.out, scale=0)
set.seed(101)
x=matrix(rnorm(100*2),100,2)
xmean=matrix(rnorm(8,sd=4),4,2)
which=sample(1:4,100,replace=TRUE)
x=x+xmean[which,]
plot(x,col=which,pch=19)
km.out=kmeans(x,4,nstart=15)
km.out
plot(x,col=km.out$cluster,cex=2,pch=1,lwd=2)
points(x,col=which,pch=19)
points(x,col=c(4,3,2,1)[which],pch=19)
hc.complete=hclust(dist(x),method="complete")
plot(hc.complete)
hc.single=hclust(dist(x),method="single")
plot(hc.single)
hc.average=hclust(dist(x),method="average")
plot(hc.average)
hc.cut=cutree(hc.complete,4)
table(hc.cut,which)
table(hc.cut,km.out$cluster)
plot(hc.complete,labels=which)
pca.out=prcomp(USArrests, scale=TRUE)
pca.out
names(pca.out)
biplot(pca.out, scale=0)
USArrests
fit <- glm(Rape ~ ., data=USArrests)
fit
summary(fit)
plot(USArrests$UrbanPop, USArrests$Rape)
abline(fit)
fit <- glm(Rape ~ UrbanPop + Assault + I(UrbanPop*Assault), data=USArrests)
fit
summary(fit)
plot(USArrests$UrbanPop, USArrests$Rape)
abline(fit)
fit <- glm(Rape ~ UrbanPop, data=USArrests)
plot(USArrests$UrbanPop, USArrests$Rape)
abline(fit)
fit <- glm(Rape ~ UrbanPop + poly(UrbanPop, 2), data=USArrests)
plot(USArrests$UrbanPop, USArrests$Rape)
abline(fit)
line(fit)
plot(fit)
fit <- glm(Rape ~ UrbanPop + poly(UrbanPop, 2) + poly(UrbanPop, 3), data=USArrests)
summary(fit)
fit <- glm(Rape ~ I(UrbanPop^3), data=USArrests)
fit
summary(fit)
plot(USArrests$UrbanPop, USArrests$Rape)
abline(fit)
predict(fit)
lines(predict(fit))
plot(USArrests$UrbanPop, USArrests$Rape)
lines(predict(fit))
plot(predict(fit), USArrests$Rape)
fit <- glm(Rape ~ UrbanPop, data=USArrests)
plot(predict(fit), USArrests$Rape)
plot(USArrests$UrbanPop, USArrests$Rape)
lines(predict(fit))
set.seed(101)
x=matrix(rnorm(100*2),100,2)
xmean=matrix(rnorm(8,sd=4),4,2)
which=sample(1:4,100,replace=TRUE)
x=x+xmean[which,]
plot(x,col=which,pch=19)
install.packages("highr", dependencies = T)
install.packages("mime", dependencies = T)
install.packages("formatR", dependencies = T)
install.packages(c("jsonlite", "manipulate", "sandwich"))
ls
ls()
list.files()
install.packages(c("formatR", "highr", "lattice", "manipulate", "mgcv", "mime"))
install.packages(c("manipulate", "Matrix"))
install.packages(c("Formula", "manipulate", "mclust", "network", "rstudioapi"))
install.packages(c("boot", "evaluate", "gtools", "jsonlite", "manipulate", "subselect"))
install.packages(c("manipulate", "roxygen2"))
install.packages("rjson", dependencies = T)
install.packages("manipulate")
install.packages(c("evaluate", "formatR", "highr", "manipulate", "markdown", "mclust", "plyr", "RANN", "RMySQL"))
install.packages(c("knitr", "manipulate", "maptools", "RCurl", "sp"))
install.packages(c("earth", "Hmisc", "manipulate", "plotmo", "Quandl", "Rcpp", "stringr"))
ls()
env()
env.profile()
install.packages(c("manipulate", "numDeriv"))
install.packages(c("manipulate", "pROC"))
install.packages(c("caret", "knitr", "manipulate"))
install.packages(c("devtools", "forecast", "manipulate", "mda", "plotmo"))
install.packages(c("BH", "forecast", "gam", "manipulate", "plotrix", "shiny", "testthat"))
install.packages(c("diptest", "earth", "manipulate", "Matrix", "party", "plyr", "rmarkdown", "robustbase", "rversions", "scales", "shiny", "sp", "strucchange", "survival", "XML"))
install.packages(c("chron", "cluster", "curl", "dplyr", "earth", "lava", "lme4", "manipulate", "MASS", "plotmo", "stringi"))
install.packages(c("arules", "boot", "chron", "class", "earth", "ElemStatLearn", "foreign", "httr", "KernSmooth", "manipulate", "MASS", "nlme", "nnet", "plotmo", "RCurl", "rpart", "spatial", "stringi", "tree", "XML"))
install.packages(c("curl", "foreign", "googleVis", "manipulate", "R6", "survival"))
X <- c(1,2,3,4,5,6,7,8,9)
y <- X*10 + 5
X <- jitter(X)
fit <- lm(y~X)
summary(fit)
feature <- cbind(1, X)
feature
y
plot(X,y)
abline(fit)
theta <- matrix(c(1,1), nrow=2)
theta
linReg <- function(feature, y, theta, alpha) {
hx <- feature %*% theta
sse <- sum((hx-y)^2)
cost <- sse/(2*length(y))
grad <- (t(feature) %*% (hx-y))
theta <- theta - (grad)*(alpha/length(y))
return(theta)
}
linTrain <- function(alpha, steps) {
for (i in 0:steps) {
theta <- linReg(feature, y, theta, alpha)
}
return(theta)
}
linTrain(0.1, 100)
linTrain(0.1, 1000)
feature
y
theta
alpha
linTrain(0.01, 1000)
linTrain(0.001, 1000)
linTrain(0.0001, 1000)
linTrain(0.0001, 10000)
ridge_fit <- lm.fit(y~X, lambda=0.1)
X
type(X)
dim(X)
ridge_fit <- lm.fit(y~feature, lambda=0.1)
dataset <- cbin(y, X)
dataset <- cbind(y, X)
dataset
ridge_fit <- lm.fit(y~X, lambda=0.1)
ridge_fit <- lm.fit(y~X, data=dataset, lambda=0.1)
data(longley)
longley
lm.ridge(y~., data=dataset)
require(MASS)
lm.ridge(y~., data=dataset)
dataset_df <- data.frame(dataset)
dataset_df
lm.ridge(y~., data=dataset)
lm.ridge(y~., data=dataset_df)
dataset_df <- cbind(dataset_df, 0)
dataset_df
names(dataset_df)
names(dataset_df) <- ("y", "X", "X1")
names(dataset_df) <- c("y", "X", "X1")
dataset_df
lm.ridge(y~., dataset=dataset_df)
lm.ridge(y~., data=dataset_df)
dataset_df$X1 <- 1
dataset_df
lm.ridge(y~., data=dataset_df)
lm.ridge(y~X, data=dataset_df)
names(longley)[1] <- "y"
lm.ridge(y ~ ., longley)
plot(lm.ridge(y ~ ., longley,
lambda = seq(0,0.1,0.001)))
select(lm.ridge(y ~ ., longley,
lambda = seq(0,0.1,0.0001)))
lm.ridge(y~., longley, lambda=0.1)
lm.ridge(y~., longley, lambda=0.01)
lm.ridge(y~., longley, lambda=0.001)
require(ggplot)
require(ggplot2)
pairs(longley)
View(longley)
plotmatrix(longley)
require(GGally)
help(GGally)
??GGally
ggpair(longley)
ggpairs(data=longley)
setwd("~/OneDrive/Coursera/JHU_DataSpecialization/data_science_jhu_repo/Getting_Data/")
getwd()
list.files()
require(swirl)
require(UsingR)
mydf <- read.csv(path2csv, stringsAsFactors = FALSE)
library(dplyr)
packageVersion("dplyr")
cran <- tbl_df(mydf)
list.files()
install.packages("manipulate")
?tbl_df
library(tidyr)
?gather
stocks <- data.frame(
time = as.Date('2009-01-01') + 0:9,
X = rnorm(10, 0, 1),
Y = rnorm(10, 0, 2),
Z = rnorm(10, 0, 4)
)
stocks
gather(stocks, stock, price, -time)
?separate
df <- data.frame(x = c("a.b", "a.d", "b.c"))
df
separate(x, c("A", "B"))
separate(x, c("A", "B"), data=df)
