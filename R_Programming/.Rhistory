cars
library("rpart", lib.loc="/Library/Frameworks/R.framework/Versions/3.1/Resources/library")
iris
plot(iris)
library(knitr)
library(swirl)
swirl()
>
exit
exit()
q()
data <- c[8,9,10,11,12]
data
x <- [8,9,10,11,12]
x <- c[8,9,10,11,12]
x = c[8,9,10,11,12]
x <- c(8,9,10,11,12)
x
mean(x)
??variance
var(x)
sqrt(2.5)
??deviation
sd(x)
install.packages("randomForest")
install.packages("sqldf")
??mongo
install.packages('RMongo')
install.packages(c("digest", "GGally", "Hmisc", "httr", "jsonlite", "magrittr", "mgcv", "multcomp", "RColorBrewer", "RCurl", "reshape2", "TH.data"))
install.packages("rattle")
library(rattle)
rattle()
rattle()
install.packages("RGtk2")
install.packages("chron")
install.packages("evaluate")
install.packages("coin")
install.packages("forecast")
install.packages("XML")
install.packages("optextras")
install.packages("cairoDevice")
install.packages("BH")
install.packages(c("acepack", "arules", "BB"))
install.packages("party")
install.packages(c("digest", "httr", "manipulate"))
install.packages("Matrix")
install.packages("mvtnorm")
install.packages("lme4")
install.packages("splines")
install.packages("caret")
ls
require(caret)
?caret
??caret
install.packages("googleVis")
require(googleVis)
googleVis
??googleVis
require(ISLR)
names(Smarket)
summary(Smarket)
?Smarket
pairs(Smarket,col=Smarket$Direction)
install.packages("ISLR")
require(ISLR)
names(Smarket)
summary(Smarket)
?Smarket
pairs(Smarket,col=Smarket$Direction)
??pairs
?pairs
?Smarket
glm.fit=glm(Direction~Lag1+Lag2+Lag3+Lag4+Lag5+Volume,
data=Smarket,family=binomial)
summary(glm.fit)
str(Smarket)
glm.fit=glm(Direction~Lag1+Lag2+Lag3+Lag4+Lag5+Volume,
data=Smarket,family=binomial)
summary(glm.fit)
glm.probs=predict(glm.fit,type="response")
glm.probs[1:5]
glm.pred=ifelse(glm.probs>0.5,"Up","Down")
table(glm.pred,Direction)
mean(glm.pred==Direction)
library(swirl)
swirl()
swirl()
plot(child ~ parent, galton)
plot(jitter(child,4) ~ parent, galton)
regline <- lm(child~parent, galton)
regline <- lm(child ~ parent, galton)
regrline <- lm(child~parent, galton)
abline(regrline, lwd-3, col='red')
abline(regrline, lwd=3, col='red')
summary(regrline)
data(iris)
??discriminant
library(MASS)
lda
lda()
lda(Species ~ Petal.Length + Petal.Width, data=Iris)
lda(Species ~ Petal.Length + Petal.Width, data=iris)
z <- lda(Species ~ Petal.Length + Petal.Width, data=Iris)
z <- lda(Species ~ Petal.Length + Petal.Width, data=iris)
summary(z)
plot(z)
swirl()
lirary(swirl)
library(swirl)
rm(list=ls())
swirl()
swirl()
install_from_swirl("R Programming")
install_from_swirl("Data_Analysis")
install_from_swirl("Getting_and_Cleaning_Data")
require(ISLR)
names(Smarket)
summary(Smarket)
?Smarket
pairs(Smarket,col=Smarket$Direction)
# Logistic regression
glm.fit=glm(Direction~Lag1+Lag2+Lag3+Lag4+Lag5+Volume,
data=Smarket,family=binomial)
summary(glm.fit)
glm.probs=predict(glm.fit,type="response")
glm.probs[1:5]
glm.pred=ifelse(glm.probs>0.5,"Up","Down")
attach(Smarket)
table(glm.pred,Direction)
mean(glm.pred==Direction)
# Make training and test set
train = Year<2005
head(train)
glm.fit=glm(Direction~Lag1+Lag2+Lag3+Lag4+Lag5+Volume,
data=Smarket,family=binomial, subset=train)
glm.probs=predict(glm.fit,newdata=Smarket[!train,],type="response")
glm.pred=ifelse(glm.probs >0.5,"Up","Down")
dir()
install.packages("rtools")
install.packages(c("car", "cluster", "manipulate"))
ls
install.packages(c("manipulate", "maptools"))
install.packages("devtools")
require(devtools)
con <- url("http://www.xuren.me", "r")
head(readLines(con))
readLines(con)
d <- readLines(con)
con <- url("http://www.xuren.me", "r")
d <- readLines(con)
d
require(swirl)
swirl()
info("mytest.R")
file.info("mytest.R")
file.info("mytest.R")$mode
list.files()
setwd("OneDrive/Coursera/JHU_DataSpecialization/testdir/")
list.files()
file.rename("mytest.R", "mytest2.R")
file.copy("mytest2.R", "mytest3.R")
getwd()
file.path("mytest3.R")
dir.create("testdir2")
dir.create("testdir2/testdir3")
dir.create("testdir2/testdir3", recursive=TRUE)
list.files()
unlink("testdir2", recursive = TRUE)
setwd <- old.dir
setwd(old.dir)
list.files()
setwd("OneDrive/Coursera/JHU_DataSpecialization/")
list.files()
unlick("testdir", recursive = T)
unlink("testdir", recursive = T)
unlink("testdir", recursive = TRUE)
install.packages("filehash")
setwd("~/OneDrive/Coursera/JHU_DataSpecialization/data_science_jhu_repo/R_Programming/")
getwd()
old.dir <- getwd()
dir.create("testdir1")
list.files()
file.exists("testdir1")
file.create("testscript.R")
list.files()
file.exists("testscript.R")
unlink("testdir1")
file.exists("testdir1")
list.files()
unlink("testdir1", recursive=TRUE)
file.exists("testdir1")
file.remove("testscript.R")
list.files()
file.remove("testscript.R", recursive=TRUE)
file.exists("testscript.R")
swirl()
1:20
pi:10
15:1
?':'
seq(1,20)
seq(1, 10, by=0.5)
seq(0, 10, by=0.5)
seq(5, 10, length=30)
my_seq <- seq(5, 10, length=30)
length(my_seq)
1:length(my_seq)
seq(along.with = my_seq)
seq_along(my_seq)
rep(0, times=40)
rep(c(0,1,2), times=40)
rep(c(0,1,2), times=10)
rep(c(0,1,2), each=10)
num_vect <- c(0.5,55,-10,6)
tf <- num_vect < 1
tf
num_vect >= 6
my_char <- c("My", "name", "is")
my_char
paste(my_char, collapse = " ")
my_name <- c(my_char, "Xu")
my_name
paste(my_name, collapse = " ")
paste(my_name)
paste(my_name, collapse=" ")
paste("Hello", "world", sep=" ")
paste("Hello", "world!", sep=" ")
paste(c(1:3), c("X", "Y", "Z"), sep="")
paste(LETTERS, 1:4, sep="-")
paste(LETTERS, 1:4, sep="-")
ls()
rm(list=ls())
LETTERS
y <- if (x<3) {
10
} else {
0
}
x<-5
y <- if (x<3) {
10
} else {
0
}
y
# for loops
for (i in 1:10) {
print(i)
}
x <- c("a", "b", "c", "d")
# you can iterative over each element inside a for loop
x <- c("a", "b", "c", "d")
for(letter in x) {
print(letter)
}
for(i in seq_along(x)) {
print(x[i])
}
for (i in 1:4) print(x[i])
v <- matrix(1:6, 2,3)
v
for (i in seq_len(nrow(v))) {
print(x[i])
}
v <- matrix(1:6, 2,3)
for (i in seq_len(nrow(v))) {
print(v[i])
}
v
# nested for loops
v <- matrix(1:6, 2,3)
for (i in seq_len(nrow(v))) {
for (j in seq_len(ncol(v))) {
print(v[i,j])
}
}
v
#####################################################################
# While loops
count <- 0
while (count < 10) {
print(count)
count <- count+1
}
?&&
?'&&'
5 & 5
5 & 7
0 & 1
5 && 7
(5 < 7) & (5<6)
(5 < 7) && (5<6)
(-2:2) >= 0
((-2:2) >= 0) & ((-2:2) <= 0)
((-2:2) >= 0)
((-2:2) <= 0)
((-2:2) >= 0) & ((-2:2) <= 0)
z <- 5
while (z >= 3 && z <= 10) {
print (z)
coin <- rbinom(1,1,0.5)
if(coin == 1) {
z <- z+1
} else {
z <- z-1
}
}
# repeat, next, and break
x <- 1
repeat {
if (x >= 10) {
break
} else {
print(x)
x <- x+1
}
}
# next
for (i in 1:25) {
if(i<=20) {
next
}
print("hello world")
}
# next
for (i in 1:25) {
if(i<=20) {
next
}
print(i)
print("hello world")
}
#####################################################################
# Functions
# more useful in independent R scripts or eventually in R packages
add2 <- function(x,y) {
x+y
}
add2(10,5)
above10 <- function(vector) {
use <- vector>10
vector[use]
}
x <- rep(1,20)
x
x <- rep(1,20, by=1)
x
x <- seq(1,50)
x
above10(x)
# a function that returns a vector of a user set numeric threshold
aboveN <- function(vector, n=10) {
use <- vector > n
vector[use]
}
aboveN(x)
aboveN(x,30)
colMean <- function(y) {
nc <- ncol(y)
means <- numeric(nc)
for(i in 1:nc) {
means[i] <- mean(y[,i])
}
return means
}
colMean <- function(y) {
nc <- ncol(y)
means <- numeric(nc)
for(i in 1:nc) {
means[i] <- mean(y[,i])
}
means
}
colMean(x)
colMean(iris)
colMean(iris[,-1])
iris[,1:4]
colMean(iris[,1:4])
# an improved colMean function that removes NA
colMean <- function(y, removeNA = TRUE) {
nc <- ncol(y)
means <- numeric(nc)
for(i in 1:nc) {
means[i] <- mean(y[,i], na.rm = removeNA)
}
means
}
colMean(airquality)
formals(lm)
formals(lm)
formals(sd)
# R has lazy evaluation
# arguments are only evaluated as needed
f <- function(a,b) {
a^2
}
f(2)
x
cat(x)
cat(x, sep = "-")
make.power <- function(n) {
pow <- function(x) {
x^n
}
pow
}
make.power(n = 5)
quinto <- make.power(n = 5)
quinto(3)
quinto(2)
ls(environment(quinto))
get("n", environment(quinto))
swirl()
?sample
sample(1:6, 4, replace=TRUE)
sample(1:6, 4, replace=TRUE)
sample(1:10, 10, replce=FALSE)
sample(1:20, 10, replace=FALSE)
sample(1:20, 10)
LETTERS
sample(LETTERS)
sample(c(0,1), 100, prop=c(0.3, 0.7))
sample(c(0,1), 100, prob=c(0.3, 0.7))
sample(c(0,1), 100, replace=TRUE)
sample(c(0,1), 100, replace=TRUE, prob=c(0.3, 0.7))
flips<-sample(c(0,1), 100, replace=TRUE, prob=c(0.3, 0.7))
flips
sum(flips)
?rbinom
rbinom(1, size=100, prob=0.7)
rbinom(100, size=100, prob=0.7)
flips2 <- rbinom(n=100, size=100, prob=0.7)
flips2 <- rbinom(n=100, size=1, prob=0.7)
flips2
weekday
weekdays
sum(flips2)
?rnorm
rnorm(10)
rnorm(10, mean = 100, sd = 25)
rpois(5)
rpois(n = 5, lambda = 10)
rbinom(10)
rbinom(n = 1, size = 100, n = 0.7)
rbinom(n = 100, size = 1, n = 0.7)
rbinom(n = 100, size = 100, n = 0.7)
replicate(100, rpois(n=5, lambda = 10))
my_pois<-replicate(100, rpois(n=5, lambda = 10))
my_pois <- replicate(100, rpois(n=5, lambda = 10))
my_pois <- replicate(100, rpois(5, 10))
my_pois
cm <- colMeans(my_pois)
hist(cm)
